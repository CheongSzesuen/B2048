<template>
  <div class="container" @swipe="move">
    <!--背景+按钮-->
    <div class="bg" if="{{ dark }}">
      <img src="/common/bg2.png" class="bg-img" />
      <img class="btn-reset" src="/common/reset_b.png" @click="new_game" />
      <img class="btn-undo" src="/common/undo_b.png" @click="chcb" />
      <img class="btn-info" src="/common/info_b.png" @click="openMenu()" />
    </div>
    <div class="bg" else>
      <img src="/common/bg1.png" class="bg-img" />
      <img class="btn-reset" src="/common/reset.png" @click="new_game" />
      <img class="btn-undo" src="/common/undo.png" @click="chcb" />
      <img class="btn-info" src="/common/info.png" @click="openMenu()" />
    </div>

    <!--游戏区域-->
    <div class="game-board">
      <block for="blocks">
        <text
          class="square"
          style="background-color: {{ bgc[md[$item]] }};"
          if="{{ !dark }}"
          id="{{ $item }}"
        >
          {{ getElementSymbol(md[$item]) }}
          <span if="{{ unstable[$item] > 0 }}" class="unstable-count">{{ unstable[$item] }}</span>
        </text>
        <text
          class="square"
          style="color: {{ bgc[md[$item]] }};background-color: {{ ise[$item] }}"
          else
          id="{{ $item }}"
        >
          {{ getElementSymbol(md[$item]) }}
          <span if="{{ unstable[$item] > 0 }}" class="unstable-count">{{ unstable[$item] }}</span>
        </text>
      </block>
    </div>

    <!--分数显示-->
    <text class="score">最高 {{ hsc }}</text>
    <text class="current-score">当前 {{ sco }}</text>

    <!--关于菜单-->
    <div class="menu-overlay" if="{{ menuFlag }}">
      <scroll class="menu-content" scroll-y="true" bounces="true" id="about">
        <img src="/common/about.png" />
        <img src="/common/true.png" if="{{ dark }}" class="mode-btn" @click="changeMode" />
        <img src="/common/false.png" else class="mode-btn" @click="changeMode" />
        <img src="/common/true.png" if="{{ ani }}" class="ani-btn" @click="changeani" />
        <img src="/common/false.png" else class="ani-btn" @click="changeani" />
      </scroll>
    </div>

    <!--返回按钮-->
    <img
      class="btn-back"
      src="{{ dark||menuFlag ? '/common/back_b.png' : '/common/back.png' }}"
      @click="exit('e')"
    />
  </div>
</template>

<script>
import prompt from "@system.prompt";
import storage from "@system.storage";
import folme from '@system.folme'

var sc = 0,
    ls,
    lhs,
    board = Array(4),
    added = Array(4),
    over = 0,
    lm = Array(4),
    that;
for (let i = 0; i < 4; i++) { lm[i] = new Array(4); board[i] = new Array(4); added[i] = new Array(4) }
export default {
    public: {
        blocks: [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13",
            "14",
            "15",
        ],
        md: [],
        hsc: 0,
        sco: sc,
        bgc: [],
        ise: [],
        ch: 0,
        dark: false,
        menuFlag: false,
        ani: true
    },
    onInit() {
        that = this;
        let tempc =
            "rgba(0,0,0,0) #EFE5DA #F0E0C9 #fcb477 #ff9c61 #ff865d #ff6a38 #ebcf71 #ebcc5f #ebc94f #ebc53f #ebc22c #F2B6B6 #E8ED51 #FFE3FB #E8FF8C #FFDEC9 #F5A433 #E6109B #96C4E6 #E560CD".split(
                " "
            );
        tempc.forEach((a, index) => {
            this.bgc[2 ** index] = a;
        });
        this.bgc[""] = "rgba(0, 0, 0, 0)";
        storage.get({
            key: "score",
            success: (data) => {
                if (data) {
                    let o = JSON.parse(data);
                    board = o.map
                    rm0(o.map);
                    this.hsc = o.hs;
                    this.sco = o.sc
                    this.ch = 0;
                    this.dark = o.dark
                    this.ani = o.ani
                } else this.new_game();
            }
        });
        clear(added)
    },
    getElementSymbol(value) {
        return value ? value.toString() : "";
    },
    chcb() {
        if (this.ch == 1) {
            this.hsc = lhs;
            this.sco = ls;
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    board[i][j] = lm[i][j]
                }
            }
            rm0(board);
            over = 0;
            this.save();
            this.ch = 0;
        } else {
            prompt.showToast({
                message: "不能再撤啦",
                duration: 1000
            });
        }
    },
    new_game() {
        backup()
        newgame();
        this.sco = 0;
        this.save();
        clearani()
    },
    move(eve) {
        if (this.menuFlag) {
            if (eve.direction == "right") this.exit('e')
            return
        }
        mo(eve.direction);
        if (over) {
            prompt.showToast({
                message: "Gameover!",
                duration: 2000,
            });
        }
        if (this.sco > this.hsc) {
            this.hsc = this.sco;
        }
        this.save();
    },
    save() {
        let o = {
            map: board,
            hs: this.hsc,
            sc: this.sco,
            dark: this.dark,
            ani: this.ani
        };
        storage.set({
            key: "score",
            value: JSON.stringify(o),
            success: () => { },
            fail: () => { },
        });
    },
    exit(a) {
        if (a.direction == 'right' || a == "e") {
            if (this.menuFlag) {
                folme.to({ id: "about", toState: { translateX: "192px" }, config: { duration: 0.1, ease: "out" } });
                setTimeout(() => { this.menuFlag = false; }, 100);
            }
            else this.$app.exit();
        }
    },
    openMenu() {
        this.menuFlag = true;
        setTimeout(() => {
            folme.to({ id: "about", toState: { translateX: "0px" }, config: { duration: 0.1, ease: "out" } });
        }, 50);
    },
    changeMode() {
        this.dark = !this.dark;
        this.save()
    },
    changeani() {
        this.ani = !this.ani;
        this.save()
    },
    onBackPress() {
        this.exit('e')
        return true;
    }
};

function rm0(sm) {
    let a = 0;
    for (let i = 0; i < 4; i++) {
        for (var b = 0; 4 > b; b++) {
            if (sm[i][b] == 0) {
                that.md[a] = ""
                that.ise[a] = "#00000000";
            } else {
                that.ise[a] = "#ffffff20";
                that.md[a] = sm[i][b]
            }
            a++
        }
    }
    return
}

function clear(m) {
    for (let i = 0; i < 4; i++) { m[i].fill(0) }
}

function newgame() {
    (over = 0);
    clear(board)
    newblock();
    newblock();
    rm0(board);
}

function rand_num() {
    return Math.floor(Math.random() * 1000)
}

function newblock() {
    for (var a = 3, b = rand_num() % 4, c = rand_num() % 4, d = 50 < rand_num() % 100 ? 4 : 2; 0 < a;) {
        if (0 == board[b][c]) return board[b][c] = d
        b = rand_num() % 4;
        c = rand_num() % 4;
        a--
    }
    for (a = 0; 4 > a; a++)
        for (b = 0; 4 > b; b++)
            if (0 == board[a][b]) return board[a][b] = 2
}

function mo(dir) {
    let up = canMoveUp(board),
        down = canMoveDown(board),
        right = canMoveRight(board),
        left = canMoveLeft(board);
    if (up || left || down || right) {
        let moved = false;
        switch(dir) {
            case 'up': moved = moveup(); break;
            case 'down': moved = movedown(); break;
            case 'left': moved = moveleft(); break;
            case 'right': moved = moveright(); break;
        }
        
        if (moved) {
            backup();
            clear(added);
            if (that.ani) {
                setTimeout(() => { clearani() }, 120);
                setTimeout(() => {
                    newblock();
                    rm0(board);
                }, 110);
            } else {
                newblock();
                rm0(board);
            }
        }
        return;
    }
    over = 1;
    rm0(board); 
    return;
}

function backup() {
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            lm[i][j] = board[i][j]
        }
    }
    ls = that.sco
    lhs = that.hsc
    that.ch = 1
    return
}

function fromTo(id1, id2) {
    if (that.ani) {
        id1 = id1.toString()
        id2 = id2.toString()
        let x1, y1, x2, y2;
        that.$element(id1).getBoundingClientRect({
            success: (data) => {
                x1 = data.left; 
                y1 = data.top;
            }
        })
        that.$element(id2).getBoundingClientRect({
            success: (data) => {
                x2 = data.left; 
                y2 = data.top;
            }
        })
        x2 -= x1; 
        y2 -= y1;
        folme.fromTo({ id: id1, fromState: { translateY: "0px", translateX: "0px" }, toState: { translateY: y2 + "px", translateX: x2 + "px" }, config: { duration: 0.1 } });
    }
    return 0;
}

function clearani() {
    for (let i = 0; i < 16; i++) {
        let id = i.toString()
        folme.cancel({ id: id })
        folme.setTo({ id: id, toState: { translateY: "0px", translateX: "0px" } })
    }
}

function moveleft() {
    for (var a = 0; 4 > a; a++)
        for (var b = 1; 4 > b; b++)
            if (0 != board[a][b])
                for (var c = 0; c < b; c++) {
                    if (0 == board[a][c] && noBlockHorizontal(a, c, b, board)) {
                        board[a][c] = board[a][b], board[a][b] = 0;
                        fromTo(a * 4 + b, a * 4 + c)
                        break
                    }
                    else board[a][c] == board[a][b] && noBlockHorizontal(a, c, b, board) && (0 != added[a][c] ? (board[a][c + 1] = board[a][b], board[a][b] = 0, fromTo(a * 4 + b, a * 4 + c + 1)) : (board[a][c] += board[a][b], that.sco += board[a][b] * 2, board[a][b] = 0, added[a][c] = 1, fromTo(a * 4 + b, a * 4 + c)));
                }
    return !0
}

function moveright() {
    for (var a = 0; 4 > a; a++)
        for (var b = 2; 0 <= b; b--)
            if (0 != board[a][b])
                for (var c = 3; c > b; c--)
                    if (0 == board[a][c] && noBlockHorizontal(a, b, c, board)) { board[a][c] = board[a][b], board[a][b] = 0; fromTo(a * 4 + b, a * 4 + c); break }
                    else board[a][c] == board[a][b] && noBlockHorizontal(a, b, c, board) && (0 != added[a][c] ? (board[a][c - 1] = board[a][b], board[a][b] = 0, fromTo(a * 4 + b, a * 4 + c - 1)) : (board[a][c] += board[a][b], that.sco += board[a][b] * 2, board[a][b] = 0, added[a][c] = 1, fromTo(a * 4 + b, a * 4 + c)));
    return !0
}

function moveup() {
    for (var a = 0; 4 > a; a++)
        for (var b = 1; 4 > b; b++)
            if (0 != board[b][a])
                for (var c = 0; c < b; c++) {
                    if (0 == board[c][a] && noBlockVertical(a, c, b, board)) { board[c][a] = board[b][a], board[b][a] = 0; fromTo(b * 4 + a, c * 4 + a); break }
                    else board[c][a] == board[b][a] && noBlockVertical(a, c, b, board) && (0 != added[c][a] ? (board[c + 1][a] = board[b][a], board[b][a] = 0, fromTo(b * 4 + a, (c + 1) * 4 + a)) : (board[c][a] += board[b][a], that.sco += board[c][a], board[b][a] = 0, added[c][a] = 1, fromTo(b * 4 + a, c * 4 + a)));
                }
}

function movedown() {
    for (var a = 0; 4 > a; a++)
        for (var b = 2; 0 <= b; b--)
            if (0 != board[b][a])
                for (var c = 3; c > b; c--) { if (0 == board[c][a] && noBlockVertical(a, b, c, board)) { board[c][a] = board[b][a], board[b][a] = 0; fromTo(b * 4 + a, c * 4 + a); break } else board[c][a] == board[b][a] && noBlockVertical(a, b, c, board) && (0 != added[c][a] ? (board[c - 1][a] = board[b][a], board[b][a] = 0, fromTo(b * 4 + a, (c - 1) * 4 + a)) : (board[c][a] += board[b][a], that.sco += board[c][a], board[b][a] = 0, added[c][a] = 1, fromTo(b * 4 + a, c * 4 + a))); }
}

function canMoveLeft(a) {
    for (var b = 0; 4 > b; b++)
        for (var c = 0; 4 > c; c++)
            if (0 != a[b][c] && 0 != c && (0 == a[b][c - 1] || a[b][c - 1] == a[b][c])) return !0;
    return !1
}

function canMoveRight(a) {
    for (var b = 0; 4 > b; b++)
        for (var c = 0; 4 > c; c++)
            if (0 != a[b][c] && 3 != c && (0 == a[b][c + 1] || a[b][c + 1] == a[b][c])) return !0;
    return !1
}

function canMoveUp(a) {
    for (var b = 0; 4 > b; b++)
        for (var c = 0; 4 > c; c++)
            if (0 != a[b][c] && 0 != b && (0 == a[b - 1][c] || a[b - 1][c] == a[b][c])) return !0;
    return !1
}

function canMoveDown(a) {
    for (var b = 0; 4 > b; b++)
        for (var c = 0; 4 > c; c++)
            if (0 != a[b][c] && 3 != b && (0 == a[b + 1][c] || a[b + 1][c] == a[b][c])) return !0;
    return !1
}

function noBlockHorizontal(a, b, c, d) {
    for (b += 1; b < c; b++)
        if (0 != d[a][b]) return !1;
    return !0
}

function noBlockVertical(a, b, c, d) {
    for (b += 1; b < c; b++)
        if (0 != d[b][a]) return !1;
    return !0
}
</script>

<style>
.container {
  position: relative;
  width: 192px;
  height: 490px;
}

.bg {
  position: absolute;
  width: 100%;
  height: 100%;
}

.bg-img {
  width: 100%;
  height: 100%;
}

.btn-reset {
  position: absolute;

left: 5px;
top: 387px;
width: 92px;
height: 64px;
}

.btn-undo {
  position: absolute;

left: 115px;
top: 387px;
width: 92px;
height: 64px;
}

.btn-info {
  position: absolute;
left: 65px;
top: 451px;
width: 83px;
height: 62px;
}

.btn-back {
  position: absolute;
/*back.png*/

left: 55px;
top: 7px;
width: 102px;
height: 72px;

}

.game-board {
  position: absolute;
  left: 4px;
top: 170px;
width: 206px;
height: 206px;
  padding-top: 4px;
  padding-left: 4px;
  display: flex;
  flex-wrap: wrap;
}

.square {
  width: 44px;
  height: 44px;
  margin-top: 5px;
  margin-left: 4px;
  border-radius: 13px;
  font-size: 15px;
  color: #59503f;
  font-weight: bold;
  text-align: center;
  position: relative;
}

.unstable-count {
  position: absolute;
  bottom: 2px;
  right: 2px;
  font-size: 10px;
  color: red;
  font-weight: bold;
}

.score {
  position: absolute;
  left: 0;
  top: 84px;
  width: 100%;
  font-size: 28px;
  color: rgba(255, 255, 255, 0.6);
  text-align: center;
}

.current-score {
  position: absolute;
  left: 0;
  top: 122px;
  width: 100%;
  font-size: 28px;
  color: rgba(255, 255, 255, 0.6);
  text-align: center;
}

.menu-overlay {
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0);
}

.menu-content {
  position: absolute;
  width: 100%;
  height: 100%;
}

.mode-btn {
  position: absolute;
left: 56px;
top: 636px;
width: 102px;
height: 72px;
}
.ani-btn{
position:absolute;
left: 55px;
top: 768px;
width: 102px;
height: 72px;
}
</style>
